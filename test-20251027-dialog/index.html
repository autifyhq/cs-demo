<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Parent</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; padding: 24px; }
    button { font-size: 16px; padding: 10px 16px; }
  </style>
</head>
<body>
  <h1>Parent Page</h1>
  <p>ボタン→確認→小ウィンドウ（about:blank→child.html）→親は next.html へ→親読み込み完了で子が自動クローズ。</p>

  <button id="go" type="button">実行</button>

  <script>
    const CH_NAME = 'demo-popup-flow';
    const CHILD_URL = 'child.html';
    const NEXT_URL  = 'next.html';

    const ch = new BroadcastChannel(CH_NAME);

    document.getElementById('go').addEventListener('click', (e) => {
      e.preventDefault();
      if (!confirm('処理を実行しますか？')) return;

      // ユーザー操作直後に about:blank を開く（ポップアップブロック回避）
      const popup = window.open('about:blank', 'childWin', 'width=420,height=360');
      if (!popup) { alert('ポップアップがブロックされました'); return; }

      // 一瞬 about:blank が見える → すぐ同一オリジンの子ページへ遷移
      try { popup.location.replace(CHILD_URL); } catch(_) {}

      // 子（child.html）が準備できたら親を遷移
      const onMsg = (e) => {
        if (e.data === 'child-ready') {
          ch.removeEventListener('message', onMsg);
          // 親を遷移（履歴残さないなら replace）
          location.replace(NEXT_URL);
        }
      };
      ch.addEventListener('message', onMsg);

      // 親離脱時のフォールバック：子を閉じる
      window.addEventListener('pagehide', () => {
        try { if (popup && !popup.closed) popup.close(); } catch {}
      }, { once: true });
    });
  </script>
</body>
</html>
